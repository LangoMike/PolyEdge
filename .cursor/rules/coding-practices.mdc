---
alwaysApply: true
description: Coding Standards
    0) Purpose

    Keep the codebase readable, predictable, and Vercel-ready. Favor clarity over cleverness. Use short, human-sounding single-line comments over code blocks.

    1) Commenting Style (required)

    Prefer single-line comments above the relevant block/function. Keep them descriptive but concise, like a human note.

    Good- // fetches game data from api

    Good- // compute edge using our calibrated probability vs platform price

    Avoid essays or redundant comments that repeat variable names.

    For tricky logic, add a 2–3 line comment max explaining the intent and assumptions.

    Public functions include a one-liner summary at the top. Avoid heavyweight JSDoc unless it adds real value.

    2) Languages & Tooling

    Frontend- TypeScript, Next.js 15 (RSC), React 18, Tailwind, shadcn/ui.

    Backend- Python 3.11+, FastAPI. (Type hints everywhere; docstrings for public endpoints.)

    Formatting- Prettier for JS/TS/MD/JSON; Black + Ruff for Python.

    Linting- ESLint (strict) for JS/TS; Ruff for Python.

    Tests- Vitest (or Jest) on web and API client; Pytest on FastAPI.

    3) Vercel Readiness & ESLint

    The code must be free of ESLint errors. Warnings are allowed but should be rare.

    Use strict TypeScript ("strict"- true). No any unless justified with a comment-

    // note- upstream api type unknown; safe-guarded below

    Recommended ESLint base-

    {
    "extends"- ["next/core-web-vitals", "eslint-recommended", "plugin-@typescript-eslint/recommended"],
    "parser"- "@typescript-eslint/parser",
    "plugins"- ["@typescript-eslint", "unused-imports", "import"],
    "rules"- {
        "@typescript-eslint/explicit-module-boundary-types"- "off",
        "@typescript-eslint/no-explicit-any"- "warn",
        "unused-imports/no-unused-imports"- "error",
        "no-console"- ["warn", { "allow"- ["warn", "error"] }],
        "import/order"- ["warn", { "newlines-between"- "always", "alphabetize"- { "order"- "asc" } }]
    }
    }


    Build must pass locally before PR- eslint . && tsc --noEmit && pnpm test.

    4) Project Structure (TS side)

    Group by feature where possible; colocate components, hooks, and tests.

    Use barrel files (index.ts) sparingly; must avoid circular deps.

    Absolute imports via tsconfig.json paths (e.g., @/lib, @/components).

    5) Naming & Style

    Variables/functions- camelCase; components/types- PascalCase; constants- UPPER_SNAKE.

    File names- kebab-case.tsx/ts.

    Keep functions ≤ 50 lines where possible; extract helpers for clarity.

    Don’t over-optimize prematurely; measure first.

    6) Error Handling & Logging

    UI- Fail gracefully with user-safe messages; no raw exception text.

    API client (frontend)- wrap fetches with a small helper that-

    attaches headers, parses JSON, handles non-2xx with a typed error.

    // fetches market prices and normalizes to internal shape

    Backend- Use structured logs (level, message, context). No secrets in logs.

    7) Security & Secrets

    No secrets in code, comments, or tests. Use env vars (process.env.* / os.environ).

    Validate all external input (query/body/path). Sanitize strings heading to DB/logs.

    Rate-limit any public endpoints. Add CORS rules explicitly.

    8) Accessibility (web)

    Semantic HTML first; ARIA only when necessary.

    Interactive controls must be keyboard accessible and labeled.

    Color contrast meets WCAG AA.

    9) Performance (web)

    Prefer Server Components; keep Client Components minimal.

    Memoize expensive selectors/hooks. Avoid re-render storms.

    Lazy-load charts/tables below the fold.

    10) Unit Tests (required for major functions)

    Write fast, deterministic unit tests for-

    Probability calibration (isotonic/Platt)

    Tests- monotonicity, calibration bin assignment, boundary cases (0/1), shape preservation.

    Example-

    calibrate(probs=[0.1,0.5,0.9], labels=[…]) returns calibrated probs in [0,1], preserves order where expected.

    Ranking logic

    Tests- sorting by edge, success_prob, tie-breakers, data freshness gating.

    Validate we exclude items when freshness > threshold or confidence bin is “Low”.

    API handlers

    Tests- GET /picks returns schema-valid results, respects filters (league, market_type, sort), and error paths (bad params).

    Mock PolyRouter client; don’t hit the network.

    Coverage targets (gateway to merge)-

    Lines ≥ 85%, Branches ≥ 75% on ml/ feature builders, ranking, and API handlers.

    Suggested stacks

    Web/API client- Vitest + @testing-library/react + msw (mock fetch).

    FastAPI- Pytest + httpx test client + pytest-cov.

    11) Git Commit Messages
    As we build, add each major addition/modification/removal to a file called "git-commit-message".
    When I commit I will copy/paste the contents of the file as a commit message to log major changes. 
    Since this is going to be a command run on the terminal, do not use any characters that will mess up the command (i.e "")
---
